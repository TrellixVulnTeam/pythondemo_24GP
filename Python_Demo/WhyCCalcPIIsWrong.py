'''
在C语言的rand()函数中精确的实现了0-32765的概率（由大数据统计分析可得，十分逼近概率）
而因此想要精确的得到其他的数的概率是十分困难的  比如rand()%100在0-99中
其实可以看作0-32765顺序对100求余在第327循环后会多出65个数，即可以看作
0-65出现的概率要比66-99的概率多1/327约等于0.003。在求精确概率时，
比如π值的投针法运算起到极大的误差

'''
"""以下重现C语言中误差的过程（假设数量级很大可以用数学期望代替）

C语言的实际概率 = 3.120917

于是我们先让C语言的rand()的RAND_MAX = 32724（发生器为准确）
正常情况下的概率：
for i in range(101):
    for j in range(101):
	    if i**2+j**2 <= 10000:
		    hits += 1
	    totol += 1
hits/totol = 0.7798255073032055
hits/totol * 4 = 3.119302029212822

几率相等的情况下：
32724*32724=1070860176
根据上面的概率应该命中
1070860176 * hits/totol = 835084080.0=835084080次
      x ∧
        |
 32765  |□□□□□□□
 32724  |▇▇▇▇▇▇□
        |▇▇▇▇▇▇□
        |▇▇▇▇▇▇□
        |▇▇▇▇▇▇□
        |▇▇▇▇▇▇□
        |▇▇▇▇▇▇□
        ●------------->
                32724  y
                  32765
                  
补上x的1/327的概率:
for i in range(42):
	for j in range(32766):
	    if (i%101)**2+(j%101)**2 <= 10000:
		    hits += 1
	    totol += 1
hits/totol = 0.9660972610981767
根据上面的概率应该命中
1343365 * hits/totol = 1297821.2=1297821次
      x ∧
        |
 32765  |▇▇▇▇▇▇▇
 32724  |▇▇▇▇▇▇□
        |▇▇▇▇▇▇□
        |▇▇▇▇▇▇□
        |▇▇▇▇▇▇□
        |▇▇▇▇▇▇□
        |▇▇▇▇▇▇□
        ●------------->
                32724  y
                  32765
加上y的1/327的概率:
for i in range(32725):
    for j in range(42):
	    if (i%101)**2+(j%101)**2 <= 10000:
		    hits += 1
	    totol += 1
hits/totol = 0.9660547855505839
根据上面的概率应该命中
1341684 * hits/totol = 1296140.24=1296140次
      x ∧
        |
 32765  |▇▇▇▇▇▇▇
 32724  |▇▇▇▇▇▇▇
        |▇▇▇▇▇▇▇
        |▇▇▇▇▇▇▇
        |▇▇▇▇▇▇▇
        |▇▇▇▇▇▇▇
        |▇▇▇▇▇▇▇
        ●------------->
                32724  y
                  32765


         835084080+1297821+1296140    837678041
所以概率= ------------------------- = ---------- = 0.7802913389140174
                32765*32765          1073545225

0.7802913389140174*4 = 3.1211653556560695

相比C语言运行多次的几率：
3.120810
3.121060
3.121437

近似相等于模拟出来的概率，所以解释了C语言为什么无法准确的实现投针法求π

"""



